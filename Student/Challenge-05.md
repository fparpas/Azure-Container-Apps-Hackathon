# Challenge 05 - Scaling Your Application

[< Previous Challenge](./Challenge-04.md) - **[Home](../README.md)** - [Next Challenge >](./Challenge-06.md)

## Introduction
Modern applications must scale seamlessly to match demand. In this challenge, you will explore the scaling mechanisms in Azure Container Apps to ensure resiliency under load.

Azure Container Apps manage automatic horizontal scaling through a set of declarative scaling rules. As a container app revision scales out, new instances of the revision are created on demand. These instances are known as replicas.

Adding or editing scaling rules creates a new revision of your container app. A revision is an immutable snapshot of your container app.

### Scale Definition
Scaling is the combination of limits, rules, and behavior.
- **Limits** define the minimum and maximum possible number of replicas per revision as your container app scales.
- **Rules** are the criteria used by Container Apps to decide when to add or remove replicas.
- **Behavior** is the combination of rules and limits to determine scale decisions over time.

> [!NOTE]
> If you want to ensure that an instance of your revision is always running, set the minimum number of replicas to 1 or higher.

### Scale Rules
Scaling is driven by three different categories of triggers:
- **HTTP**: Based on the number of concurrent HTTP requests to your revision.
- **TCP**: Based on the number of concurrent TCP connections to your revision.
- **Custom**: Based on CPU, memory, or supported event-driven data sources such as:
    - Azure Service Bus
    - Azure Event Hubs
    - Apache Kafka
    - Redis

## Description
- Create and deploy your container app using a public container image: `mcr.microsoft.com/dotnet/samples:aspnetapp`.
- Make your container app available to public requests.
- Configure autoscaling rules based on the HTTP scaling rule with the following configuration:
    - Minimum replicas: 1
    - Maximum replicas: 10
    - HTTP scale rule concurrency: 5
    - Target port: 8080
- Simulate load to trigger autoscaling using a Bash shell or PowerShell:
```bash
  # Bash: Simulate load to trigger autoscaling with a Bash shell.
  seq 1 100 | xargs -Iname -P10 curl "<YOUR_CONTAINER_APP_FQDN>"
```
```powershell
 # PowerShell: Simulate load to trigger autoscaling with PowerShell.
  $url="<YOUR_CONTAINER_APP_FQDN>"
  $Runspace = [runspacefactory]::CreateRunspacePool(1,10)
  $Runspace.Open()
  1..100 | % {
      $ps = [powershell]::Create()
      $ps.RunspacePool = $Runspace
      [void]$ps.AddCommand("Invoke-WebRequest").AddParameter("UseBasicParsing", $true).AddParameter("Uri", $url)
      [void]$ps.BeginInvoke()
  }
```
- Analyze what happens during scale-out and scale-in events.

## Success Criteria
- Autoscaling rules are correctly applied.
- The app scales and then scales back when the load decreases.
- Observe the effects of your application scaling by viewing the logs generated by the Container Apps runtime.
- Observe the effects of your application scaling by viewing the scaling in the Azure portal.

## Learning Resources
- [Set scaling rules in Azure Container Apps](https://learn.microsoft.com/en-us/azure/container-apps/scale-app?pivots=azure-portal)
- [Tutorial: Scale a container app](https://learn.microsoft.com/en-us/azure/container-apps/tutorial-scaling)
- [KEDA in Container Apps](https://learn.microsoft.com/en-us/azure/container-apps/keda)